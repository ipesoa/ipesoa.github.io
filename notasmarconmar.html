<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <!-- Viewport ajustado para que no haga zoom extraño en móvil -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Algunas notas del mar (con mar) - Editorial I.PESOA</title>
    
    <link rel="stylesheet" href="style.css">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/addons/p5.sound.min.js"></script>
    
    <style>
        /* --- ESTILOS GENERALES --- */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden; 
            background-color: transparent; 
            font-family: var(--font-main, 'Georgia', serif);
            color: var(--text-color, #000);
            height: 100vh;
            width: 100vw;
            /* Previene selección de texto accidental al tocar en móvil */
            user-select: none; 
            -webkit-user-select: none;
        }

        /* --- LIENZO P5 (FONDO) --- */
        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            z-index: -1; 
        }

        /* --- HEADER Y TÍTULO --- */
        #info-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            text-align: center;
            z-index: 100; /* Capa alta */
            padding-top: 2rem;
            pointer-events: none; 
        }

        header h1 {
            font-size: 1.5rem;
            letter-spacing: 0.1em;
            margin: 0;
            text-transform: uppercase;
            background-color: rgba(255,255,255,0.7); 
            display: inline-block;
            padding: 5px 15px;
            border-radius: 2px;
        }

        main h2 {
            font-weight: normal;
            font-style: italic;
            margin-top: 1.5rem;
            font-size: 1.2rem;
            background-color: rgba(255,255,255,0.7);
            display: inline-block;
            padding: 5px 15px;
            border-radius: 2px;
        }

        /* --- BOTÓN VOLVER --- */
        #nav-footer {
            position: fixed;
            bottom: 30px;
            width: 100%;
            text-align: center;
            z-index: 200; 
        }

        #nav-footer a {
            color: var(--text-color, #000);
            text-decoration: none;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 12px 20px; /* Botón más grande para dedo en móvil */
            font-size: 1rem;
            border-radius: 4px;
            border-bottom: 1px solid transparent;
            transition: border-bottom 0.3s;
            pointer-events: auto;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        /* --- TEXTO DE AYUDA (MEJORADO) --- */
        #start-hint {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.1rem; /* Texto más grande */
            
            /* Sin animación automática. Se queda hasta que interactúes */
            opacity: 1; 
            transition: opacity 1s ease-out; /* Se desvanecerá suavemente al tocar */
            
            z-index: 150;
            background-color: rgba(255,255,255,0.9);
            padding: 15px 25px;
            border-radius: 4px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            pointer-events: none;
            text-align: center;
        }

        /* Clase para ocultar el hint suavemente */
        .hidden-hint {
            opacity: 0 !important;
        }
    </style>
</head>
<body>

    <div id="info-container">
        <header>
            <h1>EDITORIAL I.PESOA</h1>
        </header>
        <main>
            <h2>Algunas notas del mar</h2>
        </main>
    </div>

    <!-- Texto fijo hasta que toques -->
    <div id="start-hint">Toca la pantalla para escuchar, desactiva el silencio en tu movil</div>

    <div id="nav-footer">
        <a href="articulos-publicos.html">Volver a Artículos Públicos</a>
    </div>

    <script>
        // --- CONFIGURACIÓN DE AUDIO ---
        let scaleBbMinorPent = [58, 61, 63, 66, 68];
        let noteColors = {}; 
        let voices = [];
        let numVoices = 18; 
        let waveTypes = ['sine', 'triangle', 'sawtooth']; 

        // VOLUMEN SUBIDO LIGERAMENTE PARA MÓVIL
        let masterVol = 0.6; 
        let baseAmp = 0.05; 

        let minCircleSize, maxCircleSize;
        let nextTriggerTime = 0; 
        let circles = [];
        let compressor; 
        let audioStarted = false;

        // --- NUEVAS VARIABLES PARA EL RUIDO BLANCO (OLAS) ---
        let seaNoise, seaFilter;
        let seaPlaying = false;
        let seaStartTime = 0;
        let seaDuration = 0; 
        let seaMaxFreq = 1400; // Máximo que se abrirá en la ola actual
        let nextSeaTriggerTime = 0;

        function setup() {
            let cnv = createCanvas(windowWidth, windowHeight);
            cnv.style('z-index', '-1');
            cnv.style('position', 'fixed');

            updateSizeLimits();

            colorMode(HSL, 360, 100, 100, 1);
            noStroke();
            ellipseMode(RADIUS);

            for (let i = 0; i < scaleBbMinorPent.length; i++) {
                noteColors[scaleBbMinorPent[i]] = random(0, 360); 
            }

            compressor = new p5.Compressor();
            compressor.threshold(-30); 
            compressor.ratio(12);      
            compressor.attack(0.01);
            compressor.release(0.25);
            compressor.connect();      

            // --- CONFIGURACIÓN RUIDO BLANCO ---
            seaNoise = new p5.Noise('white');
            seaNoise.disconnect(); // Desconectamos del master directo
            seaFilter = new p5.LowPass();
            seaNoise.connect(seaFilter); // Ruido -> Filtro
            seaFilter.disconnect();
            seaFilter.connect(compressor); // Filtro -> Compresor (para mezclar con el resto)
            seaNoise.start();
            seaNoise.amp(0); // Empezar en silencio
            seaFilter.freq(10); // Empezar cerrado

            // Voces melódicas originales
            for (let i = 0; i < numVoices; i++) {
                let osc = new p5.Oscillator('sine'); 
                let env = new p5.Envelope();
                let filt = new p5.LowPass();
                
                osc.disconnect();
                osc.connect(filt);
                filt.disconnect(); 
                filt.connect(compressor); 
                
                osc.start();
                osc.amp(0); 

                voices.push({ osc, env, filt, isPlaying: false });
            }
        }

        function draw() {
            background(0, 0, 100, 0.2); 

            let currentTime = millis();

            if (audioStarted) {
                // --- LÓGICA DE NOTAS (ORIGINAL) ---
                if (currentTime >= nextTriggerTime) {
                    triggerNextChord();
                    nextTriggerTime = currentTime + random(3000, 6000);
                }

                // --- NUEVA LÓGICA: RUIDO BLANCO (OLA) ---
                // 1. Disparar nueva ola si toca
                if (!seaPlaying && currentTime >= nextSeaTriggerTime) {
                    triggerSeaWave();
                }

                // 2. Controlar la ola mientras suena
                if (seaPlaying) {
                    let elapsed = currentTime - seaStartTime;

                    // Si la ola terminó
                    if (elapsed >= seaDuration) {
                        seaPlaying = false;
                        seaNoise.amp(0, 0.1); // Asegurar silencio suave
                        seaFilter.freq(10);
                        // Programar la siguiente ola (espera entre 1 y 3 segundos)
                        nextSeaTriggerTime = currentTime + random(1000, 2500);
                    } else {
                        // --- AQUÍ ESTÁ EL FILTRO SINE QUE PEDISTE ---
                        // Calculamos el progreso de 0 a 1
                        let progress = elapsed / seaDuration;
                        
                        // Calculamos el ángulo para el seno: de 0 a PI (medio ciclo de seno)
                        // PI es el punto final del arco (media vuelta)
                        let angle = progress * PI; 
                        
                        // Obtenemos el valor del seno (va de 0 a 1 y vuelve a 0)
                        let sineVal = sin(angle);
                        
                        // Mapeamos el seno a la frecuencia:
                        // 0 (cerrado) -> 10Hz
                        // 1 (abierto) -> seaMaxFreq (aleatorio, max 1200)
                        let currentFreq = map(sineVal, 0, 1, 10, seaMaxFreq);
                        
                        seaFilter.freq(currentFreq);
                    }
                }
            }

            for (let i = circles.length - 1; i >= 0; i--) {
                let c = circles[i];
                c.x += c.vx;
                c.y += c.vy;

                let elapsed = (currentTime - c.startTime) / 1000.0;
                let adsr = c.adsr;
                let totalDur = adsr.a + adsr.d + adsr.sTime + adsr.r;
                let currentAlpha = 0;

                if (elapsed < adsr.a) {
                    currentAlpha = map(elapsed, 0, adsr.a, 0, c.maxAlpha);
                } else if (elapsed < adsr.a + adsr.d + adsr.sTime) {
                    currentAlpha = c.maxAlpha;
                } else if (elapsed < totalDur) {
                    let startRel = adsr.a + adsr.d + adsr.sTime;
                    currentAlpha = map(elapsed, startRel, totalDur, c.maxAlpha, 0);
                } else {
                    voices[c.voiceIndex].isPlaying = false; 
                    circles.splice(i, 1); 
                    continue; 
                }

                currentAlpha = constrain(currentAlpha, 0, 1);
                fill(c.hue, c.sat, c.light, currentAlpha);
                ellipse(c.x, c.y, c.size, c.size);
            }
        }

        // --- FUNCIÓN PARA INICIAR LA OLA ---
        function triggerSeaWave() {
            seaPlaying = true;
            seaStartTime = millis();
            
            // "durar entre 4 y 8" (segundos) -> 4000 a 8000 ms
            seaDuration = random(6000, 12000);
            
            // "cuanto se abre sera random, siendo 1200 lo mas abierto posible"
            // Ponemos un mínimo razonable (ej. 400hz) para que se note algo
            seaMaxFreq = random(400, 1400); 

            // Control de volumen para acompañar (ADSR simple)
            // Sube volumen a la mitad y baja, sincronizado con el filtro
            let durSec = seaDuration / 1000.0;
            let peakVol = 0.15; // Volumen suave para no tapar notas
            
            seaNoise.amp(0);
            // Sube al pico en la mitad del tiempo
            seaNoise.amp(peakVol, durSec / 2); 
            // Baja a 0 en la segunda mitad
            seaNoise.amp(0, durSec / 2, durSec / 2); 
        }

        function triggerNextChord() {
            let notesToPlay = floor(random(2, 3)); 
            for (let k = 0; k < notesToPlay; k++) playNote();
        }

        function playNote() {
            let vIndex = voices.findIndex(v => !v.isPlaying);
            if (vIndex === -1) return;

            let v = voices[vIndex];
            v.isPlaying = true; 

            let note = random(scaleBbMinorPent);
            let freq = midiToFreq(note);
            let wave = random(waveTypes);
            v.osc.setType(wave);

            let volMult = 1.0; 
            if (wave === 'sawtooth') { 
                volMult = 0.4; 
                v.filt.freq(random(200, 1500));
            } 
            else if (wave === 'triangle') { 
                volMult = 0.4; 
                v.filt.freq(random(300, 2500));
            } 
            else { 
                volMult = 0.4; 
                v.filt.freq(random(500, 3500)); 
            }

            v.filt.res(random(0.1, 2.0)); 
            let finalAmp = baseAmp * volMult;
            let atk = random(0.5, 2.0);
            let susTime = random(2.0, 5.0);
            let rel = random(4.0, 12.0);

            v.env.setADSR(atk, 0.5, 0.5, rel);
            v.env.setRange(finalAmp, 0); 
            v.osc.freq(freq);
            v.env.play(v.osc, 0, susTime);

            circles.push({
                voiceIndex: vIndex,
                x: random(width * 0.1, width * 0.9),
                y: random(height * 0.1, height * 0.9),
                vx: random(-0.15, 0.15), 
                vy: random(-0.15, 0.15),
                size: random(minCircleSize, maxCircleSize), 
                hue: noteColors[note],            
                sat: random(70, 100),    
                light: random(50, 70),   
                maxAlpha: random(0.05, 0.12), 
                startTime: millis(),
                adsr: { a: atk, d: 0.5, sTime: susTime, r: rel }
            });
        }

        function updateSizeLimits() {
            if (width < 600) { 
                minCircleSize = 60; maxCircleSize = 250; // Ajustado para móvil
            } else { 
                minCircleSize = 150; maxCircleSize = 650; // PC
            }
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            updateSizeLimits();
        }

        // --- GESTIÓN DE INTERACCIÓN (MÓVIL Y PC) ---
        
        // Función unificada para iniciar audio
        function initAudio() {
            // Verificar si el click fue en el botón de footer (para no bloquear navegación)
            let footer = document.getElementById('nav-footer');
            if (footer && footer.contains(event.target)) return;

            if (!audioStarted) {
                userStartAudio().then(() => {
                    outputVolume(masterVol); 
                    audioStarted = true;
                    
                    // Inicializar tiempos
                    nextTriggerTime = millis();
                    nextSeaTriggerTime = millis() + 500; // La ola empieza medio segundo después

                    // Ocultar hint añadiendo clase CSS
                    let hint = document.getElementById('start-hint');
                    if(hint) hint.classList.add('hidden-hint');
                });
            }
        }

        // Evento ratón (PC)
        function mousePressed() {
            initAudio();
        }

        // Evento táctil (Móvil) - ESENCIAL PARA QUE SUENE
        function touchStarted() {
            initAudio();
            // return false; // Comentado para permitir scroll/zoom si fuera necesario, 
                             // pero en app fullscreen a veces es mejor dejarlo false.
                             // Aquí lo dejo normal para que el botón de volver funcione bien.
        }
    </script>
</body>
</html>
